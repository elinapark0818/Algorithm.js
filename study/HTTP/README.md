## HTTP

---

### HTTP 요청 메소드

주어진 리소스가 수행하길 원하는 행동을 말한다.

- GET : 특정 리소스의 표시를 요청. 리소스를 클라이언트로 가져다 달라고 요청하는 것
- HEAD : GET의 요청과 동일한 응답을 요구하지만, 응답 본문에 포함하지 않는다
- POST : 특정 리소스에 엔티티를 제출할 때 쓰인다. 데이터가 서버로 들어가야 함을 의미
  (리소스를 새로 만들거나 수정하기 위해 | 클라이언트로 돌려 보낼 임시 문서를 생성하기 위해)
- PUT : 목적 리소스의 모든 현재 표시를 요청 payload 로 바꾼다
- DELETE : 특정 리소스를 삭제한다
- CONNECT : 목적 리소스로 식별되는 서버로의 터널을 맺는다.(연결 통로를 만든다)
- OPTION : 목적 리소스의 통신을 설정할 때 쓰인다.
- TRACE : 목적 리소스의 경로를 다라 메시지 loop-back 테스트를 실행한다
- PATCH : 리소스를 부분 수정할 때 쓰인다.

## <br/>

### HTTP 메시지

서버와 클라이언트 간 데이터가 교환되는 방식이다.

1. request (요청) : 클라이언트가 서버로 전달해서 서버의 액션이 발생하게 만드는 메시지
2. response (응답) : request(요청)에 대한 서버의 답변 메시지

<img src="https://user-images.githubusercontent.com/74189121/147204275-00fa18d2-74fb-46e4-8435-6835ddf77953.png">

- HTTP 요청과 응답의 구조

  1. start-line에 수행되어야 할 request(요청) 또는 response(응답)은 수행에 대한 성공 또는 실패가 기록되어 있다.
  2. 옵션으로 HTTP Headers가 들어갈 수 있다. HTTP Headers에는 request(요청)에 대한 설명 또는 메시지 본문에 대한 설명이 들어간다.
  3. 요청에 대한 모든 메타정보가 전송되었음을 알리는 blank-line(빈 줄)이 삽입된다.
  4. request(요청)과 관련된 내용이 옵션으로 들어가거나, response(응답)과 관련된 문서(document)가 들어간다. 본문의 존재 유무 및 크기는 start-line과 HTTP Header에 명시된다.

    <img src="https://user-images.githubusercontent.com/74189121/147205079-51e3745a-e91b-4e89-930d-dc00652df972.png">

<br/>

##### HTTP request

- start-line :

  1. 첫 번째로 오는 HTTP 메소드로 GET, PUT, POST 또는 HEAD, OPTIONS 를 통해 서버가 수행해야 할 동작을 나타낸다.
  2. 두 번째로 오는 요청타겟은 주로 URL, PROTOCOL, PORT, DOMAIN 의 절대경로로 나타낼 수 있다. 요청타겟은 요청 컨텍스트에 의해 특정지어진다. 요청타겟 포멧은 HTTP 메소드에 따라 달라진다.
     - 요청 타겟 포멧
       - origin 형식 : '?'와 쿼리문자열이 붙는 절대 경로. (GET, POST, HEAD, OPTIONS 와 함께 사용한다)
       - absolute 형식 : 완전한 URL 형식이다. 프록시에 연결하는 경우 대부분 GET과 함께 사용된다
       - authority 형식 : 도메인 이름과 옵션포트로 이루어진 URL의 authority component이다. HTTP 터널을 구축하는 경우에만 CONNECT와 함께 사용할 수 있다
       - asterisk 형식 : OPTIONS와 함께 '\*'로 간단하게 서버 전체를 나타낸다
  3. 세 번째로(마지막으로) HTTP 버전이 들어간다. 메시지의 남은 구조를 결정하기 때문에 response(응답) 메시지에서 써야하는 HTTP 버전을 알려주는 역할을 한다

- Header : request(요청)에 들어가는 HTTP 헤더는 HTTP 헤더의 기본구조를 따른다.

  - HTTP 헤더의 기본구조 : 대소문자 구분없는 문자열 다음에 콜론(:)이 붙고, 그 뒤에 오는 값은 헤더에 따라 달라진다. 헤더는 값까지 포함해 한 줄로 구성되지만 꽤 길어질 수도 있다.

    - Request Header(요청 헤더)

      1. General Header : 'Via'와 같은 헤더는 메시지 전체에 적용된다.
      2. Request Header : 'User-Agent (en-US)', 'Accept-Type'와 같은 헤더는 요청의 내용을 좀 더 구체화시키고(Accept-Language),, 컨텍스를 제공하기도 하며(Refer), 조건에 따른 제약 사항을 가하기도 하면서(If-None) 요청 내용을 수정한다.
      3. Entity Header : 'Content-Length'와 같은 헤더는 요청 본문에 적용된다. 당연히 요청 내에 본문이 없다면 Entity Header는 전송되지 않는다.

      <img src="https://user-images.githubusercontent.com/74189121/147207564-293ef69d-328c-4f02-a1fd-e9f10e5307f1.png">

- body :

  1. 본문은 요청의 마지막 부분에 들어간다. (모든 요청에 본문이 들어가지는 않는다)
  2. GET, HEAD, DELETE, OPTIONS 처럼 리소스를 가져오는 request(요청)의 경우 보통 본문이 필요없다.
  3. 일부 요청은 업데이트를 하기 위해 서버에 데이터를 전송한다 (보통 HTML 폼 데이터를 포함하는 'POST' 요청일 경우)

- 본문의 구성
  1. 단일-리소스 본문(single-resource bodies) : 2개의 헤더와 정의된 단일 파일로 구성된다.
  2. 다중-리소스 본문(multiple-resource bodies) : 멀티파트 본문으로 구성되는 다중 리소스 본문에서는 파트마다 다른 정보를 지니게 된다. (보통 HTML 폼과 관련이 있다.)

<br/>

##### HTTP response

- status-line : 상태 줄
  1. 프로토콜 버전
  2. 상태 HTTP 코드
  3. 상태 텍스트

```
HTTP/1.1 404 Not Found
```

- Header : response(응답)에 들어가는 HTTP 헤더는 HTTP 헤더의 기본구조를 따른다. === request header와 동일한 구조이다

  - Response Header(응답 헤더)

    1. General Header : 'Via'와 같은 헤더는 메시지 전체에 적용된다.
    2. Response Header : 'Vary'와 'Accept-Ranges'와 같은 헤더는 상태 줄에 미처 들어가지 못했던 서버에 대한 추가 정보를 제공한다
    3. Entity Header : 'Content-Length'와 같은 헤더는 요청 본문에 적용된다. 당연히 요청 내에 본문이 없다면 Entity Header는 전송되지 않는다.

    <img src="https://user-images.githubusercontent.com/74189121/147239021-b6e94058-9983-4de1-9cd2-34db93622d77.png">

- body :

  1. 본문은 요청의 마지막 부분에 들어간다. (201, 204 와 같은 상태 코드를 가진 응답에는 보통 본문이 없다)

- 본문의 구성
  1. 이미 길이가 알려진 단일 파일로 구성된 단일-리소스 본문 : 헤더 두 개(Content-Type와 Content-Length)로 정의한다
  2. 길이를 모르는 단일 파일로 구성된 단일-리소스 본문 : 'Transfer-Encoding'가 'chunked'로 설정되어 있으며, 파일은 청크로 나뉘어 인코딩 되어 있다
  3. 서로 다른 정보를 담고 있는 멀티파트로 이루어진 다중-리소스 본문 : 이 경우는 상대적으로 위의 두 경우에 비해 보기 힘들다

<br/>

### HTTP/2 프레임

HTTP/1.x 메시지는 몇 가지 성능상의 결함을 내포하고 있다.

- 본문은 압축이 되지만, 헤더는 압축되지 않는다
- 연속된 메시지들은 비슷한 헤더구조를 띄기 마련인데, 그럼에도 불구하고 메시지마다 반복되어 전송되고 있다
- 다중전송(multiplexing) 불가능 : 서버 하나에 여러 개의 연결을 열어야 한다. (적극적인(warm) TCP 연결이 소극적인(cold) TCP 연결보다 효율적임에도 불가하다)

HTTP/2 에서는 추가적인 단계가 도입되었다.
HTTP/1.x 메시지를 프레임으로 나누어 스트림에 끼워 넣는다!
끼워넣음으로써 데이터와 헤더 프레임이 분리되었기 때문에 <b>헤더를 압축</b>할 수 있다.
스트림 여러 개를 하나로 묶을 수 있어서(multiplexing) 기저에서 수행되는 TCP 연결이 조금 더 효율적으로 이루어진다.

<img src="https://user-images.githubusercontent.com/74189121/147240103-4736da52-138f-4328-8c66-0a4a1af7a001.png">

<br/>

#### HTTP 프레임

HTTP 프레임은 HTTP/2 에서 추가된 단계이며
HTTP/1.1 메시지와 그 기저를 이루는 전송 프로토콜 사이를 메워주는 존재이다.
(그렇다고 해서 HTTP 프레임 때문에 개발자들이 API를 바꿀 필요는 없다. 브라우정와 서버 모두 HTTP 프레임을 받아들일 수 있다면, HTTP/2가 활성화 된 이후에 사용될 것이다.)

<br/>

### 결론

HTTP 메시지는 HTTP에서 핵심적인 역할을 한다.
메시지 구조는 단순하게 이루어졌고, 확장성도 매우 좋다.
HTTP/2 프레이밍 메커니즘 덕분에 HTTP/1.x 구문과 기저가 되는 전송 프로토콜 사이에 새로운 중간 단계가 추가되었다.
프로토콜을 자체적으로 수정하지 않고, 이미 입증된 메커니즘을 바탕으로 이뤄낸 것이다!

---

<br/>

### HTTP code

2xx 성공
200: 클라이언트의 요청을 정상적으로 수행함.
201: 클라이언트에게 생성 작업을 요청 받았고, 생성 작업을 성공함.
204: 요청은 성공 했지만 응답할 콘텐츠가 없음.

3xx 리다이렉션
301: 클라이언트가 요청한 리소스에 대한 URI가 영구적으로 변경되었을 때 사용함.
302: 301과 같으나 임시적으로 주소가 바뀌었을 경우 사용함.
304: 이전에 방문했을 때의 요청 결과와 다르지 않을 경우 사용함. 캐시된 페이지를 그대로 사용.
307: 임시 페이지로 리다이렉트.

4xx 클라이언트 오류
400: 클라이언트가 올바르지 못한 요청을 보냄.
401: 로그인을 하지 않아 페이지를 열 권한이 없음.
403: 금지된 페이지, 로그인을 하든 안하든 접근할 수 없음. (관리자 페이지)
404: 찾을 수 없는 페이지, 주소를 잘 못 입력했을 때 사용함.
403 대신에 사용할 수도 있음.(해커들의 공격을 방지하고자 페이지가 없는 것처럼 위장함)
408: 요청 시간이 초과됨.
409: 서버가 요청을 처리하는 과정에서 충돌이 발생한 경우. (회원가입 중 중복된 아이디인 경우)
410: 영구적으로 사용할 수 없는 페이지.

5xx 서버 오류
501: 해당 요청을 처리하는 기능이 만들어지지 않음.
502: 서버로 가능 요청이 중간에서 유실된 경우.
503: 서버가 터졌거나 유지 보수 중
(유지 보수 중일때는 유지 보수중이라는 것을 알려주는 페이지로 전송해주는 것이 좋음)
504: 서버 게이트웨이에 문제가 생겨 시간 초과가 된 경우.
505: HTTP 버전이 달라 요청이 처리할 수 없음.
